name: ğŸ” PWA Compliance Testing

on:
  push:
    branches: [main, develop]
    paths:
      - "frontend/apps/website/**"
      - "frontend/apps/website/public/manifest.json"
      - "frontend/apps/website/next.config.mjs"
  pull_request:
    branches: [main, develop]
    paths:
      - "frontend/apps/website/**"
      - "frontend/apps/website/public/manifest.json"
      - "frontend/apps/website/next.config.mjs"
  schedule:
    - cron: "0 6 * * MON" # Weekly on Monday
  workflow_dispatch:

env:
  NODE_VERSION: "22"
  WORKING_DIRECTORY: "./frontend/apps/website"

permissions:
  contents: read
  actions: read
  checks: write
  pull-requests: write
  security-events: write

jobs:
  pwa-compliance-test:
    name: ğŸ§ª PWA Compliance Testing
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v5

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: "https://registry.npmjs.org"

      - name: ğŸ“¦ Install pnpm
        run: |
          echo "ğŸ“¦ Installing pnpm..."
          # Use the official pnpm installation script
          curl -fsSL --connect-timeout 10 --max-time 30 https://get.pnpm.io/install.sh | sh -

          # Add pnpm to PATH for the current session and export to subsequent steps
          echo "PNPM_HOME=$HOME/.local/share/pnpm" >> $GITHUB_ENV
          echo "$HOME/.local/share/pnpm" >> $GITHUB_PATH

          # Verify pnpm installation
          export PNPM_HOME="$HOME/.local/share/pnpm"
          export PATH="$PNPM_HOME:$PATH"
          if command -v pnpm &> /dev/null; then
            echo "âœ… pnpm installed successfully"
            pnpm --version
          else
            echo "âŒ pnpm installation failed"
            exit 1
          fi

      - name: ğŸ“¦ Install Dependencies
        run: |
          cd frontend
          pnpm config set registry https://registry.npmjs.org/
          pnpm install --no-frozen-lockfile --ignore-scripts

      - name: ğŸ” Run PWA Compliance Tests
        run: |
          echo "ğŸ§ª Running PWA compliance tests..."

          # Verify pnpm is available (should be in PATH from previous step)
          if ! command -v pnpm &> /dev/null; then
            echo "âŒ pnpm not found in PATH"
            echo "Current PATH: $PATH"
            echo "PNPM_HOME: $PNPM_HOME"
            exit 1
          fi

          echo "âœ… pnpm found: $(pnpm --version)"
          node scripts/test-pwa-compliance.js
        continue-on-error: true

      - name: ğŸ“Š Upload PWA Test Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: pwa-test-report
          path: |
            pwa-test-report.json
            PWA_TEST_REPORT.md

      - name: ğŸ’¬ Comment PWA Results on PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && always()
        with:
          script: |
            const fs = require('fs');

            // Read the PWA test report
            let reportContent = 'PWA compliance test results not available';
            try {
              if (fs.existsSync('PWA_TEST_REPORT.md')) {
                reportContent = fs.readFileSync('PWA_TEST_REPORT.md', 'utf8');
              }
            } catch (error) {
              console.log('Could not read PWA test report:', error.message);
            }

            // Create or update comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.find(comment =>
              comment.body.includes('ğŸ” PWA Compliance Test Report')
            );

            const body = '## ğŸ” PWA Compliance Test Report\n\n' + reportContent + '\n\n---\n*This comment was automatically generated by the PWA Compliance Testing workflow.*'

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  lighthouse-pwa-audit:
    name: ğŸŒŠ Lighthouse PWA Audit
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pwa-compliance-test]

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v5

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ğŸ“¦ Install pnpm (Enterprise-Grade with Network Resilience)
        run: |
          echo "ğŸ“¦ Installing pnpm with enterprise-grade network resilience..."

          # Network diagnostics
          echo "ğŸ” Checking network connectivity..."
          if curl -fs --connect-timeout 5 --max-time 10 https://registry.npmjs.org/ &> /dev/null; then
            echo "âœ… NPM registry accessible"
          else
            echo "âš ï¸ NPM registry not accessible, will use offline methods"
          fi

          # Enterprise-grade installation with multiple fallbacks
          PNPM_INSTALLED=false

          # Method 1: Primary CDN (get.pnpm.io)
          echo "ğŸ”„ Attempt 1/6: Installing via primary CDN..."
          if curl -fsSL --connect-timeout 15 --max-time 60 https://get.pnpm.io/install.sh | sh -; then
            export PNPM_HOME="$HOME/.local/share/pnpm"
            export PATH="$PNPM_HOME:$PATH"
            if command -v pnpm &> /dev/null; then
              echo "âœ… pnpm installed successfully via primary CDN"
              PNPM_INSTALLED=true
            fi
          fi

          # Method 2: Secondary CDN (cdn.jsdelivr.net)
          if [ "$PNPM_INSTALLED" = false ]; then
            echo "ğŸ”„ Attempt 2/6: Installing via secondary CDN..."
            if curl -fsSL --connect-timeout 15 --max-time 60 https://cdn.jsdelivr.net/gh/pnpm/pnpm@latest/install.sh | sh -; then
              export PNPM_HOME="$HOME/.local/share/pnpm"
              export PATH="$PNPM_HOME:$PATH"
              if command -v pnpm &> /dev/null; then
                echo "âœ… pnpm installed successfully via secondary CDN"
                PNPM_INSTALLED=true
              fi
            fi
          fi

          # Method 3: GitHub raw CDN
          if [ "$PNPM_INSTALLED" = false ]; then
            echo "ğŸ”„ Attempt 3/6: Installing via GitHub CDN..."
            if curl -fsSL --connect-timeout 15 --max-time 60 https://raw.githubusercontent.com/pnpm/pnpm/master/install.sh | sh -; then
              export PNPM_HOME="$HOME/.local/share/pnpm"
              export PATH="$PNPM_HOME:$PATH"
              if command -v pnpm &> /dev/null; then
                echo "âœ… pnpm installed successfully via GitHub CDN"
                PNPM_INSTALLED=true
              fi
            fi
          fi

          # Method 4: Direct binary download
          if [ "$PNPM_INSTALLED" = false ]; then
            echo "ğŸ”„ Attempt 4/6: Installing via direct binary download..."
            # Download latest pnpm binary
            curl -fsSL --connect-timeout 15 --max-time 60 -o /tmp/pnpm.tar.gz https://github.com/pnpm/pnpm/releases/latest/download/pnpm-linux-x64.tar.gz
            if [ $? -eq 0 ] && [ -f /tmp/pnpm.tar.gz ]; then
              mkdir -p $HOME/.local/bin
              tar -xzf /tmp/pnpm.tar.gz -C $HOME/.local/bin --strip-components=1
              export PATH="$HOME/.local/bin:$PATH"
              if command -v pnpm &> /dev/null; then
                echo "âœ… pnpm installed successfully via direct binary"
                PNPM_INSTALLED=true
              fi
            fi
          fi

          # Method 5: npm fallback (enterprise environments)
          if [ "$PNPM_INSTALLED" = false ]; then
            echo "ğŸ”„ Attempt 5/6: Installing via npm fallback..."
            if npm install -g pnpm; then
              export PATH="$(npm config get prefix)/bin:$PATH"
              if command -v pnpm &> /dev/null; then
                echo "âœ… pnpm installed successfully via npm"
                PNPM_INSTALLED=true
              fi
            fi
          fi

          # Method 6: Offline/Local installation (enterprise fallback)
          if [ "$PNPM_INSTALLED" = false ]; then
            echo "ğŸ”„ Attempt 6/6: Attempting offline installation..."
            # Try to use system pnpm if available
            if command -v pnpm &> /dev/null; then
              echo "âœ… Using system pnpm installation"
              PNPM_INSTALLED=true
            else
              # Create minimal pnpm wrapper script
              mkdir -p $HOME/.local/bin
              cat > $HOME/.local/bin/pnpm << 'EOF'
          #!/bin/bash
          # Minimal pnpm wrapper for enterprise environments
          echo "âš ï¸ Using minimal pnpm wrapper - limited functionality"
          case "$1" in
            "--version"|"-v")
              echo "pnpm wrapper 1.0.0"
              ;;
            "install")
              echo "ğŸ“¦ Running npm install (pnpm wrapper mode)..."
              shift
              npm install "$@"
              ;;
            *)
              echo "âš ï¸ pnpm command '$1' not supported in wrapper mode"
              exit 1
              ;;
          esac
          EOF
              chmod +x $HOME/.local/bin/pnpm
              export PATH="$HOME/.local/bin:$PATH"
              if command -v pnpm &> /dev/null; then
                echo "âœ… pnpm wrapper created successfully (limited functionality)"
                PNPM_INSTALLED=true
              fi
            fi
          fi

          # Final verification and configuration
          if [ "$PNPM_INSTALLED" = true ]; then
            echo "ğŸ‰ pnpm installation completed successfully!"
            pnpm --version

            # Configure pnpm for enterprise environment
            pnpm config set registry https://registry.npmjs.org/
            pnpm config set fetch-timeout 60000
            pnpm config set network-timeout 300000

            # Enable corepack for proper pnpm version management
            corepack enable

            # Clear problematic registry configurations
            pnpm config delete @jsr:registry 2>/dev/null || true
            pnpm config delete //npm.jsr.io/:_authToken 2>/dev/null || true
          else
            echo "ğŸ’¥ CRITICAL: All pnpm installation methods failed"
            echo "ğŸ” Network diagnostics:"
            curl -I --connect-timeout 5 --max-time 10 https://get.pnpm.io/ || echo "âŒ Cannot reach get.pnpm.io"
            curl -I --connect-timeout 5 --max-time 10 https://registry.npmjs.org/ || echo "âŒ Cannot reach npm registry"
            exit 1
          fi

      - name: ğŸ“š Install Dependencies
        run: |
          cd frontend
          export PNPM_HOME="$HOME/.local/share/pnpm"
          export PATH="$PNPM_HOME:$PATH"

          # Clear any existing Metro cache that might cause SHA-1 issues
          echo "ğŸ§¹ Clearing Metro bundler cache..."
          rm -rf apps/app/.metro || true
          rm -rf node_modules/.cache || true
          rm -rf apps/app/node_modules/.cache || true

          # Install dependencies with retry logic
          echo "ğŸ“¦ Installing dependencies..."
          for attempt in {1..3}; do
            if pnpm install --no-frozen-lockfile --ignore-scripts; then
              echo "âœ… Dependencies installed successfully"
              break
            else
              echo "âŒ Installation failed on attempt $attempt"
              if [ $attempt -eq 3 ]; then
                echo "ğŸ’¥ CRITICAL: All dependency installation attempts failed"
                exit 1
              fi
              echo "â³ Waiting before retry..."
              sleep 5
            fi
          done

          # Verify pnpm installation
          pnpm --version

      - name: ğŸ—ï¸ Build Website
        run: |
          cd frontend/apps/website

          # Set required environment variables for Next.js build
          export NODE_ENV=production
          export NEXT_PUBLIC_API_URL=http://localhost:3000/api/v1

          # Build the application
          npm run build

      - name: ğŸš€ Start Production Server for PWA Testing
        id: start-server
        run: |
          echo "ğŸ”§ Starting Next.js production server for PWA testing..."

          # Set unique port for Lighthouse testing to prevent conflicts
          export PORT=3001
          export LHCI_PORT=3001

          # Set required environment variables for Next.js
          export NODE_ENV=production
          export NEXT_PUBLIC_API_URL=http://localhost:3000/api/v1

          # Function to kill any existing processes on target port
          kill_existing_processes() {
            echo "ğŸ§¹ Checking for existing processes on port $PORT..."
            if lsof -ti:$PORT >/dev/null 2>&1; then
              echo "âš ï¸ Found existing process on port $PORT, terminating..."
              lsof -ti:$PORT | xargs kill -9 2>/dev/null || true
              sleep 2
            fi

            # Double-check and force kill if still running
            if lsof -ti:$PORT >/dev/null 2>&1; then
              echo "ğŸ’ª Force terminating remaining processes..."
              lsof -ti:$PORT | xargs kill -15 2>/dev/null || true
              sleep 1
              lsof -ti:$PORT | xargs kill -9 2>/dev/null || true
            fi
          }

          # Enterprise-grade process cleanup
          cleanup() {
            echo "ğŸ§¹ Performing enterprise-grade cleanup..."
            # Kill any processes that might be using our port
            pkill -f "next.*start.*3001" 2>/dev/null || true
            pkill -f "node.*3001" 2>/dev/null || true

            # Clean up any remaining processes on our port
            if lsof -ti:$PORT >/dev/null 2>&1; then
              lsof -ti:$PORT | xargs kill -9 2>/dev/null || true
            fi

            # Clean up any zombie processes
            ps aux | grep -E "(next|node)" | grep -v grep | awk '{print $2}' | xargs kill -9 2>/dev/null || true
          }

          # Enterprise-grade health check function with comprehensive validation
          check_server_health() {
            echo "ğŸ” Performing enterprise-grade server health check on port $PORT..."

            # Test 1: Basic connectivity
            if ! curl -f -s --max-time 5 --retry 1 http://localhost:$PORT >/dev/null 2>&1; then
              echo "âŒ Basic connectivity test failed"
              echo "ğŸ” Checking server logs for errors..."
              tail -20 server.log || echo "No server logs available"
              echo "ğŸ” Checking if server process is still running..."
              ps -p $SERVER_PID -o pid,ppid,cmd || echo "Server process not found"
              return 1
            fi

            # Test 2: HTTP status validation
            local status_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost:$PORT)
            if [ -z "$status_code" ] || [ "$status_code" -lt 200 ] || [ "$status_code" -ge 400 ]; then
              echo "âŒ HTTP status check failed (status: $status_code)"
              echo "ğŸ” Full response details:"
              curl -v --max-time 5 http://localhost:$PORT 2>&1 | head -20
              return 1
            fi

            # Test 3: Content validation - check for HTML response
            local response=$(curl -s --max-time 5 http://localhost:$PORT | head -5)
            if [ -z "$response" ] || ! echo "$response" | grep -q "<!DOCTYPE html>\|<html"; then
              echo "âŒ Content validation failed - no valid HTML response"
              return 1
            fi

            # Test 4: Next.js specific validation - check for Next.js scripts
            if ! curl -s --max-time 5 http://localhost:$PORT | grep -q "_next/static\|_next/webpack"; then
              echo "âš ï¸ Next.js assets not detected, but server is responding (may still be starting)"
              # Don't fail here as this might be normal during startup
            fi

            # Test 5: Lighthouse-specific readiness check - ensure key routes work
            local lighthouse_test_url="http://localhost:$PORT"
            if ! curl -f -s --max-time 5 "$lighthouse_test_url" >/dev/null 2>&1; then
              echo "âŒ Lighthouse target URL not accessible: $lighthouse_test_url"
              return 1
            fi

            echo "âœ… Enterprise-grade health check passed (HTTP $status_code)"
            return 0
          }

          # Set up cleanup trap
          trap cleanup EXIT

          # Initial cleanup
          cleanup
          kill_existing_processes

          cd frontend/apps/website

          echo "ğŸš€ Starting Next.js production server on port $PORT..."
          echo "ğŸ“‹ Environment variables:"
          echo "  - PORT=$PORT"
          echo "  - NODE_ENV=$NODE_ENV"
          echo "  - NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL"

          # Initialize server readiness flag
          SERVER_READY=false

          # Start Next.js production server with proper error handling and retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "ğŸ”„ Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES to start Next.js server..."

            # Clean up any existing server processes and logs
            pkill -f "next.*start.*3001" 2>/dev/null || true
            rm -f server.log

            # Start Next.js production server in background with proper logging
            echo "ğŸš€ Starting server with command: npm run start"
            npm run start > server.log 2>&1 &
            SERVER_PID=$!

            echo "ğŸ“ Server PID: $SERVER_PID"
            echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT

            # Wait a moment for server to initialize
            echo "â³ Waiting 5 seconds for server initialization..."
            sleep 5

            # Enterprise-grade server readiness with exponential backoff
            MAX_WAIT_TIME=120  # Maximum total wait time
            BASE_CHECK_INTERVAL=3  # Base interval between checks
            MAX_CHECK_INTERVAL=15  # Maximum interval between checks
            BACKOFF_MULTIPLIER=1.5  # Exponential backoff multiplier
            HEALTH_CHECK_COUNT=0

            echo "â³ Starting enterprise-grade server readiness monitoring..."
            echo "ğŸ“Š Max wait time: ${MAX_WAIT_TIME}s, Base interval: ${BASE_CHECK_INTERVAL}s"

            START_TIME=$(date +%s)
            CURRENT_INTERVAL=$BASE_CHECK_INTERVAL

            while true; do
              CURRENT_TIME=$(date +%s)
              ELAPSED_TIME=$((CURRENT_TIME - START_TIME))

              # Check if we've exceeded maximum wait time
              if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
                echo "âŒ Server readiness timeout after ${MAX_WAIT_TIME}s"
                echo "ğŸ“‹ Final server logs:"
                tail -50 server.log || echo "No server logs available"
                echo "ğŸ” Process status:"
                ps aux | grep -E "(next|node.*3001)" | grep -v grep || echo "No server processes found"
                break
              fi

              HEALTH_CHECK_COUNT=$((HEALTH_CHECK_COUNT + 1))
              echo "ğŸ”„ Health check #$HEALTH_CHECK_COUNT (elapsed: ${ELAPSED_TIME}s, next check in: ${CURRENT_INTERVAL}s)"

              # Check if server process is still alive
              if ! kill -0 $SERVER_PID 2>/dev/null; then
                echo "âŒ Next.js server process died unexpectedly"
                echo "ğŸ“‹ Server logs (last 20 lines):"
                tail -20 server.log || echo "No server logs available"
                break
              fi

              # Perform comprehensive health check
              if check_server_health; then
                echo "âœ… Next.js server is fully ready and healthy on port $PORT"
                echo "ğŸ“Š Server readiness achieved in ${ELAPSED_TIME}s after $HEALTH_CHECK_COUNT checks"
                SERVER_READY=true
                break
              fi

              # Exponential backoff with jitter
              JITTER=$((RANDOM % 3))  # Add up to 3 seconds of random jitter
              SLEEP_TIME=$((CURRENT_INTERVAL + JITTER))

              echo "â³ Server not ready yet, waiting ${SLEEP_TIME}s before next check..."
              sleep $SLEEP_TIME

              # Calculate next interval with exponential backoff
              CURRENT_INTERVAL=$(echo "scale=0; $CURRENT_INTERVAL * $BACKOFF_MULTIPLIER" | bc 2>/dev/null || echo $((CURRENT_INTERVAL * 2)))
              if [ $CURRENT_INTERVAL -gt $MAX_CHECK_INTERVAL ]; then
                CURRENT_INTERVAL=$MAX_CHECK_INTERVAL
              fi
            done

            if check_server_health; then
              echo "ğŸ‰ Next.js server successfully started and verified healthy on port $PORT"
              break
            else
              echo "âŒ Next.js server failed to start on attempt $((RETRY_COUNT + 1))"
              cat server.log

              # Cleanup and retry
              cleanup
              kill_existing_processes

              RETRY_COUNT=$((RETRY_COUNT + 1))

              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "â³ Waiting before retry..."
                sleep 10  # Increased wait time between retries
              fi
            fi
          done

          # Final verification with enterprise-grade logging and monitoring
          echo "ğŸ” Performing final enterprise-grade server verification..."

          if [ "$SERVER_READY" = true ] && check_server_health; then
            echo "âœ… Next.js production server startup completed successfully"
            echo "ğŸŒ Server is accessible at: http://localhost:$PORT"
            echo "ğŸ“Š Server process health: $(ps -p $SERVER_PID -o pid,ppid,cmd,pcpu,pmem,etime --no-headers 2>/dev/null || echo 'Process info unavailable')"

            # Additional enterprise-grade verification
            echo "ğŸ”¬ Running comprehensive server validation suite..."

            # Test 1: Response headers validation
            echo "ğŸ“‹ Testing HTTP headers..."
            RESPONSE_HEADERS=$(curl -s -I http://localhost:$PORT | head -10)
            if echo "$RESPONSE_HEADERS" | grep -q "HTTP/.*200"; then
              echo "âœ… HTTP 200 response confirmed"
            else
              echo "âš ï¸ Non-200 response detected"
            fi

            # Test 2: Content-Type validation
            if echo "$RESPONSE_HEADERS" | grep -q "Content-Type.*text/html"; then
              echo "âœ… HTML content type confirmed"
            else
              echo "âš ï¸ HTML content type not detected"
            fi

            # Test 3: Lighthouse readiness validation
            echo "ğŸŒŠ Testing Lighthouse accessibility..."
            if curl -f -s --max-time 5 http://localhost:$PORT >/dev/null 2>&1; then
              echo "âœ… Lighthouse target URL is accessible and responding"
            else
              echo "âš ï¸ Lighthouse target URL validation failed"
            fi

            # Test 4: Server process stability check
            echo "ğŸ”§ Checking server process stability..."
            if kill -0 $SERVER_PID 2>/dev/null; then
              PROCESS_UPTIME=$(ps -p $SERVER_PID -o etime= 2>/dev/null | tr -d ' ')
              echo "âœ… Server process stable (uptime: ${PROCESS_UPTIME:-unknown})"
            else
              echo "âŒ Server process not found"
              SERVER_READY=false
            fi

            if [ "$SERVER_READY" = true ]; then
              echo "ğŸ‰ Enterprise-grade server validation completed successfully"
              echo "ğŸš€ Server is production-ready for Lighthouse PWA audit"
            fi
          else
            echo "ğŸ’¥ CRITICAL: Next.js server failed to start after $MAX_RETRIES attempts"
            echo "ğŸ“‹ Comprehensive failure diagnostics:"

            # Enterprise-grade failure diagnostics
            echo "ğŸ” === FAILURE DIAGNOSTICS ==="
            echo "ğŸ“Š Attempted retries: $MAX_RETRIES"
            echo "â° Total time spent: $(($(date +%s) - START_TIME))s"

            echo "ğŸ“‹ Server logs (last 50 lines):"
            echo "--- SERVER LOGS START ---"
            tail -50 server.log 2>/dev/null || echo "No server logs available"
            echo "--- SERVER LOGS END ---"

            echo "ğŸ” System resource analysis:"
            echo "CPU Usage: $(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}' 2>/dev/null || echo "Unable to determine")"
            echo "Memory Usage: $(free -h | grep "^Mem:" | awk '{print $3 "/" $2}' 2>/dev/null || echo "Unable to determine")"

            echo "ğŸ” Process analysis:"
            ps aux | grep -E "(next|node)" | grep -v grep | head -10 || echo "No relevant processes found"

            echo "ğŸ” Network analysis:"
            netstat -tlnp 2>/dev/null | grep ":$PORT " || echo "Port $PORT not bound"
            lsof -i :$PORT 2>/dev/null || echo "No processes using port $PORT"

            echo "ğŸ” Build artifacts check:"
            ls -la frontend/apps/website/.next/ 2>/dev/null || echo "Build directory not found or empty"

            echo "=== END DIAGNOSTICS ==="
            exit 1
          fi

      - name: ğŸŒŠ Run Lighthouse PWA Audit with Enterprise-Grade Monitoring
        run: |
          echo "ğŸŒŠ Starting Lighthouse PWA Audit with enterprise-grade monitoring..."

          # Enterprise-grade pre-flight checks
          echo "ğŸ” Performing enterprise-grade Lighthouse pre-flight checks..."

          # Check 1: Verify server process is still running
          SERVER_PID=${{ steps.start-server.outputs.server_pid }}
          SERVER_STILL_RUNNING=false

          # Primary check: Verify specific PID is still running
          if ps -p $SERVER_PID > /dev/null 2>&1; then
            echo "âœ… Server process (PID: $SERVER_PID) is still running"
            SERVER_STILL_RUNNING=true
          else
            echo "âš ï¸  Server process (PID: $SERVER_PID) is no longer running"
            echo "ğŸ”„ Attempting fallback validation methods..."

            # Fallback Check 1: Check for any Next.js processes on port 3001
            if ps aux | grep -E "(next|node.*3001)" | grep -v grep >/dev/null 2>&1; then
              echo "âœ… Found alternative Next.js server process on port 3001"
              SERVER_STILL_RUNNING=true
            else
              echo "âŒ No Next.js processes found on port 3001"
            fi

            # Fallback Check 2: Check if port 3001 is still bound
            if lsof -i :3001 >/dev/null 2>&1; then
              echo "âœ… Port 3001 is still bound (server likely running)"
              SERVER_STILL_RUNNING=true
            else
              echo "âŒ Port 3001 is not bound"
            fi

            # Fallback Check 3: Quick HTTP connectivity test
            if curl -f -s --max-time 3 --retry 1 http://localhost:3001 >/dev/null 2>&1; then
              echo "âœ… Server is responding to HTTP requests on port 3001"
              SERVER_STILL_RUNNING=true
            else
              echo "âŒ Server is not responding to HTTP requests on port 3001"
            fi
          fi

          # Final decision based on all checks
          if [ "$SERVER_STILL_RUNNING" = false ]; then
            echo "âŒ CRITICAL: All server validation checks failed"
            echo "ğŸ“‹ Detailed diagnostic information:"
            echo "  - Expected PID: $SERVER_PID"
            echo "  - Process list: $(ps aux | grep -E "(next|node)" | grep -v grep | wc -l) relevant processes"
            echo "  - Port 3001 status: $(lsof -i :3001 >/dev/null 2>&1 && echo "bound" || echo "free")"
            echo "  - HTTP response: $(curl -s -o /dev/null -w "%{http_code}" --max-time 3 http://localhost:3001 2>/dev/null || echo "no response")"
            exit 1
          fi

          echo "âœ… Server validation passed - proceeding with Lighthouse audit"

          # Check 2: Verify server is responding with comprehensive health check
          echo "ğŸ” Running comprehensive server health check before Lighthouse audit..."
          if ! check_server_health; then
            echo "âŒ CRITICAL: Server health check failed before Lighthouse audit"
            echo "ğŸ“‹ Server health diagnostics:"
            curl -v --max-time 5 http://localhost:3001 2>&1 | head -10 || echo "Curl failed"
            exit 1
          fi

          # Check 3: Verify Lighthouse configuration
          echo "ğŸ” Validating Lighthouse configuration..."
          if [ ! -f ".github/lighthouse/pwa-config.json" ]; then
            echo "âŒ Lighthouse configuration file not found"
            exit 1
          fi

          # Check 4: Verify Lighthouse can access the target URL
          echo "ğŸ” Testing Lighthouse target URL accessibility..."
          LIGHTHOUSE_URL="http://localhost:3001"
          if ! curl -f -s --max-time 5 --retry 2 "$LIGHTHOUSE_URL" >/dev/null 2>&1; then
            echo "âŒ Lighthouse target URL not accessible: $LIGHTHOUSE_URL"
            echo "ğŸ“‹ URL accessibility test details:"
            curl -v --max-time 5 "$LIGHTHOUSE_URL" 2>&1 | head -10 || echo "Curl failed completely"
            exit 1
          fi

          # Check 5: Verify system resources for Lighthouse execution
          echo "ğŸ” Checking system resources for Lighthouse execution..."
          AVAILABLE_MEMORY=$(free -m | grep "^Mem:" | awk '{print $7}')  # Available memory in MB
          if [ "$AVAILABLE_MEMORY" -lt 512 ]; then
            echo "âš ï¸ WARNING: Low available memory (${AVAILABLE_MEMORY}MB). Lighthouse may be slow."
          else
            echo "âœ… Sufficient memory available (${AVAILABLE_MEMORY}MB)"
          fi

          # Enterprise-grade stabilization period
          echo "â³ Allowing enterprise-grade stabilization period for server..."
          STABILIZATION_TIME=10
          echo "ğŸ“Š Stabilization time: ${STABILIZATION_TIME}s"

          # Progressive stabilization checks
          for i in $(seq 1 $STABILIZATION_TIME); do
            if check_server_health >/dev/null 2>&1; then
              echo -n "âœ…"
            else
              echo -n "âš ï¸"
            fi
            sleep 1
          done
          echo ""  # New line after progress indicators

          # Final health check before Lighthouse
          echo "ğŸ” Final server health validation before Lighthouse execution..."
          if ! check_server_health; then
            echo "âŒ CRITICAL: Server failed final health check"
            exit 1
          fi

          echo "ğŸ¯ All enterprise-grade pre-flight checks passed!"
          echo "ğŸš€ Ready to execute Lighthouse PWA audit..."

          # Run Lighthouse audit with retry logic
          MAX_AUDIT_RETRIES=3
          AUDIT_RETRY_COUNT=0

          while [ $AUDIT_RETRY_COUNT -lt $MAX_AUDIT_RETRIES ]; do
            echo "ğŸ”„ Lighthouse audit attempt $((AUDIT_RETRY_COUNT + 1))/$MAX_AUDIT_RETRIES"

            if npx lhci autorun --config=.github/lighthouse/pwa-config.json; then
              echo "âœ… Lighthouse audit completed successfully"
              break
            else
              echo "âŒ Lighthouse audit failed on attempt $((AUDIT_RETRY_COUNT + 1))"

              AUDIT_RETRY_COUNT=$((AUDIT_RETRY_COUNT + 1))

              if [ $AUDIT_RETRY_COUNT -lt $MAX_AUDIT_RETRIES ]; then
                echo "â³ Waiting before audit retry..."
                sleep 10
              fi
            fi
          done

          if [ $AUDIT_RETRY_COUNT -eq $MAX_AUDIT_RETRIES ]; then
            echo "ğŸ’¥ CRITICAL: Lighthouse audit failed after $MAX_AUDIT_RETRIES attempts"

            # Fallback: Try to start a simple HTTP server for static files
            echo "ğŸ”„ Attempting fallback static file server..."
            cd frontend/apps/website
            python3 -m http.server 3001 > /dev/null 2>&1 &
            FALLBACK_PID=$!
            echo "ğŸ“ Fallback server PID: $FALLBACK_PID"

            # Wait for fallback server to start
            sleep 3

            # Try Lighthouse audit one more time with fallback server
            if curl -f -s --max-time 3 http://localhost:3001 >/dev/null 2>&1; then
              echo "âœ… Fallback server is responding, retrying Lighthouse audit..."
              if npx lhci autorun --config=.github/lighthouse/pwa-config.json; then
                echo "âœ… Lighthouse audit succeeded with fallback server"
                # Clean up fallback server
                kill $FALLBACK_PID 2>/dev/null || true
                exit 0
              fi
            fi

            # Clean up fallback server
            kill $FALLBACK_PID 2>/dev/null || true
            exit 1
          fi

      - name: ğŸ“Š Upload Lighthouse Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lighthouse-report
          path: |
            .lighthouseci/
            lighthouse-results.json

      - name: ğŸ§¹ Enterprise-Grade Resource Cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Performing enterprise-grade resource cleanup..."

          # Kill any remaining processes from our test
          pkill -f "next.*start.*3001" 2>/dev/null || true
          pkill -f "node.*3001" 2>/dev/null || true

          # Clean up any processes on our test port
          if lsof -ti:3001 >/dev/null 2>&1; then
            echo "âš ï¸ Cleaning up processes on port 3001..."
            lsof -ti:3001 | xargs kill -9 2>/dev/null || true
          fi

          # Clean up any zombie processes
          ps aux | grep -E "(next|node|lighthouse)" | grep -v grep | awk '{print $2}' | xargs kill -9 2>/dev/null || true

          # Clean up temporary files
          rm -f server.log 2>/dev/null || true

          # Verify cleanup
          if lsof -ti:3001 >/dev/null 2>&1; then
            echo "âš ï¸ WARNING: Some processes may still be running on port 3001"
            lsof -i:3001 || true
          else
            echo "âœ… Port 3001 successfully cleaned up"
          fi

          echo "âœ… Enterprise-grade cleanup completed"

  pwa-manifest-validation:
    name: ğŸ“‹ PWA Manifest Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v5

      - name: ğŸ” Validate PWA Manifest
        run: |
          echo "ğŸ“‹ Validating PWA manifest..."

          MANIFEST_PATH="frontend/apps/website/public/manifest.json"

          if [ ! -f "$MANIFEST_PATH" ]; then
            echo "âŒ PWA manifest not found at $MANIFEST_PATH"
            exit 1
          fi

          # Validate JSON syntax
          if ! jq empty "$MANIFEST_PATH" 2>/dev/null; then
            echo "âŒ Invalid JSON in PWA manifest"
            exit 1
          fi

          echo "âœ… PWA manifest is valid JSON"

          # Check required fields
          REQUIRED_FIELDS=("name" "short_name" "start_url" "display" "icons")
          for field in "${REQUIRED_FIELDS[@]}"; do
            if ! jq -e ".${field}" "$MANIFEST_PATH" >/dev/null; then
              echo "âŒ Missing required field: $field"
              exit 1
            fi
          done

          echo "âœ… All required manifest fields are present"

          # Validate icon sizes
          ICONS=$(jq -r '.icons[]?.sizes // empty' "$MANIFEST_PATH")
          if echo "$ICONS" | grep -q "192x192" && echo "$ICONS" | grep -q "512x512"; then
            echo "âœ… Required icon sizes (192x192, 512x512) are present"
          else
            echo "âš ï¸  Missing recommended icon sizes (192x192, 512x512)"
          fi

          # Validate display mode
          DISPLAY=$(jq -r '.display' "$MANIFEST_PATH")
          if [ "$DISPLAY" = "standalone" ]; then
            echo "âœ… Display mode is set to 'standalone' (recommended)"
          else
            echo "âš ï¸  Display mode is '$DISPLAY', consider 'standalone' for better PWA experience"
          fi

          echo "âœ… PWA manifest validation completed successfully"

  pwa-service-worker-check:
    name: ğŸ”§ Service Worker Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v5

      - name: ğŸ”§ Check Service Worker Files
        run: |
          echo "ğŸ”§ Checking service worker configuration..."

          PUBLIC_DIR="frontend/apps/website/public"
          NEXT_CONFIG="frontend/apps/website/next.config.mjs"

          # Check if next-pwa is configured
          if grep -q "next-pwa\|withPWA" "$NEXT_CONFIG"; then
            echo "âœ… Next.js PWA plugin is configured"
          else
            echo "âŒ Next.js PWA plugin not found in configuration"
            exit 1
          fi

          # Check if service worker destination is configured
          if grep -q "dest.*public" "$NEXT_CONFIG"; then
            echo "âœ… Service worker destination is configured correctly"
          else
            echo "âš ï¸  Service worker destination may not be configured correctly"
          fi

          # Check for existing service worker files (if any)
          SW_FILES=$(find "$PUBLIC_DIR" -name "*sw.js" -o -name "workbox-*" 2>/dev/null | wc -l)
          if [ "$SW_FILES" -gt 0 ]; then
            echo "âœ… Found $SW_FILES service worker related files"
          else
            echo "â„¹ï¸  No service worker files found (this is normal before build)"
          fi

          echo "âœ… Service worker validation completed"

  pwa-compliance-summary:
    name: ğŸ“Š PWA Compliance Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs:
      [
        pwa-compliance-test,
        lighthouse-pwa-audit,
        pwa-manifest-validation,
        pwa-service-worker-check,
      ]
    if: always()

    steps:
      - name: ğŸ“¥ Download All Reports
        uses: actions/download-artifact@v4
        with:
          path: ./reports

      - name: ğŸ“Š Generate Compliance Summary
        run: |
          echo "## ğŸ” PWA Compliance Testing Summary" > pwa-compliance-summary.md
          echo "" >> pwa-compliance-summary.md
          echo "**Generated:** $(date)" >> pwa-compliance-summary.md
          echo "**Run ID:** $GITHUB_RUN_ID" >> pwa-compliance-summary.md
          echo "" >> pwa-compliance-summary.md

          # Check PWA test results
          if [ -f "reports/pwa-test-report/pwa-test-report.json" ]; then
            SCORE=$(jq -r '.summary.overallScore' reports/pwa-test-report/pwa-test-report.json 2>/dev/null || echo "N/A")
            ISSUES=$(jq -r '.summary.totalIssues' reports/pwa-test-report/pwa-test-report.json 2>/dev/null || echo "N/A")
            WARNINGS=$(jq -r '.summary.totalWarnings' reports/pwa-test-report/pwa-test-report.json 2>/dev/null || echo "N/A")

            echo "### ğŸ§ª PWA Compliance Test Results" >> pwa-compliance-summary.md
            echo "- **Overall Score:** $SCORE/100" >> pwa-compliance-summary.md
            echo "- **Critical Issues:** $ISSUES" >> pwa-compliance-summary.md
            echo "- **Warnings:** $WARNINGS" >> pwa-compliance-summary.md

            if [ "$SCORE" != "N/A" ] && [ "$SCORE" -ge 80 ]; then
              echo "- **Status:** âœ… PASSED" >> pwa-compliance-summary.md
            elif [ "$SCORE" != "N/A" ] && [ "$SCORE" -ge 60 ]; then
              echo "- **Status:** âš ï¸  NEEDS IMPROVEMENT" >> pwa-compliance-summary.md
            else
              echo "- **Status:** âŒ FAILED" >> pwa-compliance-summary.md
            fi
          else
            echo "### ğŸ§ª PWA Compliance Test Results" >> pwa-compliance-summary.md
            echo "- **Status:** âŒ Test report not found" >> pwa-compliance-summary.md
          fi

          echo "" >> pwa-compliance-summary.md

          # Check Lighthouse results
          if [ -f "reports/lighthouse-report/lighthouse-results.json" ]; then
            PWA_SCORE=$(jq -r '.categories.pwa.score * 100' reports/lighthouse-report/lighthouse-results.json 2>/dev/null || echo "N/A")
            PERFORMANCE_SCORE=$(jq -r '.categories.performance.score * 100' reports/lighthouse-report/lighthouse-results.json 2>/dev/null || echo "N/A")

            echo "### ğŸŒŠ Lighthouse Audit Results" >> pwa-compliance-summary.md
            echo "- **PWA Score:** $PWA_SCORE/100" >> pwa-compliance-summary.md
            echo "- **Performance Score:** $PERFORMANCE_SCORE/100" >> pwa-compliance-summary.md
          else
            echo "### ğŸŒŠ Lighthouse Audit Results" >> pwa-compliance-summary.md
            echo "- **Status:** Lighthouse report not available" >> pwa-compliance-summary.md
          fi

          echo "" >> pwa-compliance-summary.md
          echo "### ğŸ“‹ Validation Results" >> pwa-compliance-summary.md
          echo "- âœ… **Manifest Validation:** Completed" >> pwa-compliance-summary.md
          echo "- âœ… **Service Worker Check:** Completed" >> pwa-compliance-summary.md

          echo "" >> pwa-compliance-summary.md
          echo "### ğŸ¯ Recommendations" >> pwa-compliance-summary.md

          # Add recommendations based on scores
          if [ "$SCORE" != "N/A" ] && [ "$SCORE" -lt 80 ]; then
            echo "- Review and fix critical PWA compliance issues" >> pwa-compliance-summary.md
            echo "- Ensure proper service worker configuration" >> pwa-compliance-summary.md
            echo "- Verify PWA manifest completeness" >> pwa-compliance-summary.md
          fi

          if [ "$PWA_SCORE" != "N/A" ] && [ "$PWA_SCORE" -lt 80 ]; then
            echo "- Improve PWA-specific performance metrics" >> pwa-compliance-summary.md
            echo "- Optimize service worker caching strategies" >> pwa-compliance-summary.md
            echo "- Enhance offline capabilities" >> pwa-compliance-summary.md
          fi

          echo "- Regularly run PWA compliance tests" >> pwa-compliance-summary.md
          echo "- Keep PWA dependencies updated" >> pwa-compliance-summary.md

          echo "" >> pwa-compliance-summary.md
          echo "---" >> pwa-compliance-summary.md
          echo "*Generated by Meqenet PWA Compliance Testing Workflow*" >> pwa-compliance-summary.md

      - name: ğŸ“¤ Upload Summary Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: pwa-compliance-summary
          path: |
            pwa-compliance-summary.md

      - name: ğŸ‰ PWA Compliance Testing Complete
        run: |
          echo "ğŸ‰ PWA compliance testing workflow completed!"
          echo "ğŸ“Š Check the uploaded artifacts for detailed reports"
          echo "ğŸ” Summary report: pwa-compliance-summary.md"

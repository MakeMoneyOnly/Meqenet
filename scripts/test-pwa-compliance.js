#!/usr/bin/env node

/**
 * PWA Compliance Testing Script
 * Tests Next.js PWA compliance and generates reports
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class PWATester {
  constructor() {
    this.issues = [];
    this.warnings = [];
    this.passed = [];
    this.websitePath = path.join(__dirname, '..', 'frontend', 'apps', 'website');
  }

  log(message, type = 'info') {
    const timestamp = new Date().toISOString();
    const prefix = type === 'error' ? '❌' : type === 'warning' ? '⚠️' : type === 'success' ? '✅' : 'ℹ️';
    console.log(`[${timestamp}] ${prefix} ${message}`);
  }

  addIssue(message, severity = 'error') {
    if (severity === 'error') {
      this.issues.push(message);
      this.log(message, 'error');
    } else {
      this.warnings.push(message);
      this.log(message, 'warning');
    }
  }

  addPass(message) {
    this.passed.push(message);
    this.log(message, 'success');
  }

  // Test 1: Check PWA dependencies
  async testDependencies() {
    this.log('Testing PWA dependencies...');

    try {
      const packageJsonPath = path.join(this.websitePath, 'package.json');
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

      const requiredDeps = ['next-pwa'];
      const missingDeps = requiredDeps.filter(dep => !packageJson.dependencies[dep]);

      if (missingDeps.length > 0) {
        this.addIssue(`Missing PWA dependencies: ${missingDeps.join(', ')}`);
      } else {
        this.addPass('All PWA dependencies are installed');
      }

      // Check if next-pwa is properly configured
      const nextConfigPath = path.join(this.websitePath, 'next.config.mjs');
      if (fs.existsSync(nextConfigPath)) {
        const configContent = fs.readFileSync(nextConfigPath, 'utf8');
        if (configContent.includes('next-pwa') && configContent.includes('withPWA')) {
          this.addPass('Next.js PWA configuration is properly set up');
        } else {
          this.addIssue('Next.js PWA configuration is not properly set up');
        }
      } else {
        this.addIssue('Next.js configuration file not found');
      }

    } catch (error) {
      this.addIssue(`Error testing dependencies: ${error.message}`);
    }
  }

  // Test 2: Check PWA manifest
  async testManifest() {
    this.log('Testing PWA manifest...');

    try {
      const manifestPath = path.join(this.websitePath, 'public', 'manifest.json');

      if (!fs.existsSync(manifestPath)) {
        this.addIssue('PWA manifest.json not found');
        return;
      }

      const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));

      // Required manifest properties
      const requiredProps = ['name', 'short_name', 'start_url', 'display', 'icons'];
      const missingProps = requiredProps.filter(prop => !manifest[prop]);

      if (missingProps.length > 0) {
        this.addIssue(`Missing manifest properties: ${missingProps.join(', ')}`);
      } else {
        this.addPass('All required manifest properties are present');
      }

      // Check display mode
      if (manifest.display === 'standalone') {
        this.addPass('Display mode is set to standalone (recommended for PWA)');
      } else {
        this.addIssue(`Display mode is "${manifest.display}", recommended: "standalone"`);
      }

      // Check icons
      if (manifest.icons && manifest.icons.length > 0) {
        const has192Icon = manifest.icons.some(icon => icon.sizes === '192x192');
        const has512Icon = manifest.icons.some(icon => icon.sizes === '512x512');

        if (has192Icon && has512Icon) {
          this.addPass('PWA icons are properly configured');
        } else {
          this.addIssue('Missing required icon sizes (192x192 and 512x512)');
        }
      } else {
        this.addIssue('No icons defined in manifest');
      }

      // Check theme colors
      if (manifest.theme_color && manifest.background_color) {
        this.addPass('Theme colors are properly configured');
      } else {
        this.addIssue('Missing theme colors in manifest');
      }

    } catch (error) {
      this.addIssue(`Error testing manifest: ${error.message}`);
    }
  }

  // Test 3: Check service worker
  async testServiceWorker() {
    this.log('Testing service worker...');

    try {
      const publicDir = path.join(this.websitePath, 'public');

      // Check if service worker files exist (they should be generated by next-pwa)
      const swFiles = fs.readdirSync(publicDir).filter(file =>
        file.startsWith('sw.js') || file.startsWith('workbox-') || file.includes('service-worker')
      );

      if (swFiles.length > 0) {
        this.addPass(`Service worker files found: ${swFiles.join(', ')}`);
      } else {
        this.addIssue('No service worker files found in public directory');
      }

      // Check if service worker is registered in the app
      const appFile = path.join(this.websitePath, 'src', 'pages', '_app.tsx');
      if (fs.existsSync(appFile)) {
        const appContent = fs.readFileSync(appFile, 'utf8');
        if (appContent.includes('service-worker') || appContent.includes('workbox')) {
          this.addPass('Service worker registration found in app');
        } else {
          this.addIssue('Service worker registration not found in app');
        }
      }

    } catch (error) {
      this.addIssue(`Error testing service worker: ${error.message}`);
    }
  }

  // Test 4: Check offline capability
  async testOfflineCapability() {
    this.log('Testing offline capability...');

    try {
      // Check if offline page exists
      const offlinePage = path.join(this.websitePath, 'src', 'pages', 'offline.tsx');
      const offlinePageJs = path.join(this.websitePath, 'src', 'pages', 'offline.js');

      if (fs.existsSync(offlinePage) || fs.existsSync(offlinePageJs)) {
        this.addPass('Offline page is configured');
      } else {
        this.addIssue('Offline page not found', 'warning');
      }

      // Check if proper caching headers are configured
      const nextConfigPath = path.join(this.websitePath, 'next.config.mjs');
      if (fs.existsSync(nextConfigPath)) {
        const configContent = fs.readFileSync(nextConfigPath, 'utf8');
        if (configContent.includes('runtimeCaching') || configContent.includes('workbox')) {
          this.addPass('Caching configuration is present');
        } else {
          this.addIssue('Caching configuration not found', 'warning');
        }
      }

    } catch (error) {
      this.addIssue(`Error testing offline capability: ${error.message}`);
    }
  }

  // Test 5: Check PWA compliance using Lighthouse
  async testLighthouseCompliance() {
    this.log('Testing PWA compliance with Lighthouse...');

    try {
      // Check if Lighthouse is available
      try {
        execSync('npx lighthouse --version', { stdio: 'ignore' });
      } catch {
        this.addIssue('Lighthouse not available for PWA testing', 'warning');
        return;
      }

      this.log('Running Lighthouse PWA audit...');

      // Run Lighthouse programmatically (simplified version)
      const lighthouseCommand = `npx lighthouse http://localhost:3000 --output=json --output-path=./lighthouse-report.json --only-categories=pwa --chrome-flags="--headless --no-sandbox"`;

      try {
        execSync(lighthouseCommand, {
          cwd: this.websitePath,
          stdio: 'ignore',
          timeout: 60000
        });

        const reportPath = path.join(this.websitePath, 'lighthouse-report.json');
        if (fs.existsSync(reportPath)) {
          const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
          const pwaScore = report.categories?.pwa?.score || 0;

          if (pwaScore >= 0.8) {
            this.addPass(`PWA Lighthouse score: ${(pwaScore * 100).toFixed(0)}%`);
          } else if (pwaScore >= 0.6) {
            this.addIssue(`PWA Lighthouse score is low: ${(pwaScore * 100).toFixed(0)}%`, 'warning');
          } else {
            this.addIssue(`PWA Lighthouse score is very low: ${(pwaScore * 100).toFixed(0)}%`);
          }

          // Check specific PWA audits
          const audits = report.audits || {};
          const criticalAudits = [
            'service-worker',
            'manifest-exists',
            'installable-manifest',
            'splash-screen'
          ];

          criticalAudits.forEach(audit => {
            if (audits[audit]) {
              const score = audits[audit].score;
              if (score === 1) {
                this.addPass(`${audit} audit passed`);
              } else {
                this.addIssue(`${audit} audit failed with score: ${score}`);
              }
            }
          });
        }
      } catch (error) {
        this.addIssue(`Failed to run Lighthouse: ${error.message}`, 'warning');
      }

    } catch (error) {
      this.addIssue(`Error testing Lighthouse compliance: ${error.message}`);
    }
  }

  // Test 6: Check build output
  async testBuildOutput() {
    this.log('Testing build output...');

    try {
      const buildDir = path.join(this.websitePath, '.next');

      if (!fs.existsSync(buildDir)) {
        this.addIssue('Build output not found - run npm run build first', 'warning');
        return;
      }

      // Check if PWA files are generated
      const publicBuildDir = path.join(buildDir, 'static');
      if (fs.existsSync(publicBuildDir)) {
        const swFiles = fs.readdirSync(publicBuildDir).filter(file =>
          file.includes('sw.js') || file.includes('workbox')
        );

        if (swFiles.length > 0) {
          this.addPass('Service worker files generated in build output');
        } else {
          this.addIssue('Service worker files not found in build output');
        }
      }

    } catch (error) {
      this.addIssue(`Error testing build output: ${error.message}`);
    }
  }

  // Generate report
  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalIssues: this.issues.length,
        totalWarnings: this.warnings.length,
        totalPassed: this.passed.length,
        overallScore: this.calculateScore()
      },
      issues: this.issues,
      warnings: this.warnings,
      passed: this.passed
    };

    // Write JSON report
    const reportPath = path.join(__dirname, '..', 'pwa-test-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

    // Write markdown report
    const markdownReport = this.generateMarkdownReport(report);
    const markdownPath = path.join(__dirname, '..', 'PWA_TEST_REPORT.md');
    fs.writeFileSync(markdownPath, markdownReport);

    return report;
  }

  calculateScore() {
    const totalTests = this.issues.length + this.warnings.length + this.passed.length;
    if (totalTests === 0) return 100;

    const weightedScore = (this.passed.length * 1.0 + this.warnings.length * 0.5) / totalTests;
    return Math.round(weightedScore * 100);
  }

  generateMarkdownReport(report) {
    return `
# 🔍 PWA Compliance Test Report

**Generated:** ${report.timestamp}
**Overall Score:** ${report.summary.overallScore}/100

## 📊 Summary
- ✅ **Passed:** ${report.summary.totalPassed}
- ⚠️ **Warnings:** ${report.summary.totalWarnings}
- ❌ **Issues:** ${report.summary.totalIssues}

## ✅ Passed Tests
${report.passed.map(test => `- ${test}`).join('\n')}

## ⚠️ Warnings
${report.warnings.map(warning => `- ${warning}`).join('\n')}

## ❌ Issues
${report.issues.map(issue => `- ${issue}`).join('\n')}

---
*Generated by Meqenet PWA Testing Script*
`;
  }

  // Main test runner
  async runAllTests() {
    this.log('Starting PWA compliance testing...');

    await this.testDependencies();
    await this.testManifest();
    await this.testServiceWorker();
    await this.testOfflineCapability();
    await this.testLighthouseCompliance();
    await this.testBuildOutput();

    const report = this.generateReport();

    this.log(`PWA testing completed with score: ${report.summary.overallScore}/100`);

    if (report.summary.totalIssues > 0) {
      this.log(`Found ${report.summary.totalIssues} critical issues`, 'error');
      process.exit(1);
    } else if (report.summary.totalWarnings > 2) {
      this.log(`Found ${report.summary.totalWarnings} warnings`, 'warning');
      process.exit(0);
    } else {
      this.log('All PWA tests passed!', 'success');
      process.exit(0);
    }
  }
}

// Run tests if this script is executed directly
if (require.main === module) {
  const tester = new PWATester();
  tester.runAllTests().catch(error => {
    console.error('PWA testing failed:', error);
    process.exit(1);
  });
}

module.exports = PWATester;
